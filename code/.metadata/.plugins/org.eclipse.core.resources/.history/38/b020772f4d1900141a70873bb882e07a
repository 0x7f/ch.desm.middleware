package ch.desm.middleware.modules.communication.endpoint.serial.ubw32;

import java.util.ArrayDeque;
import java.util.Deque;

/**
 * 
 */
public class EndpointUbw32Parser {

	private Deque<String> messages;
	private String buffer;
	private EndpointUbw32Cache cache;
	
	public EndpointUbw32Parser() {
		messages = new ArrayDeque<String>();
		buffer = "";
	}

	public void addData(String data) {
		this.buffer = this.buffer + data;
		parseBuffer();
	}

	public String pop() {
		return this.messages.pollFirst();
	}

	private void parseBuffer() {
		if (buffer.isEmpty()) {
			return;
		}

		String message;
		while (true) {

			// first, try to pop all known messages
			while ((message = popMessageFromBuffer()) != null) {
				messages.addLast(message);
			}

			// yeah, empty!
			if (buffer.isEmpty()) {
				break;
			}

			// buffer looks like valid data, but probably
			// some data is missing still. lets wait for it
			if (bufferProbablyBeginsWithValidData()) {
				break;
			}

			// buffer does not look like it contains valid data.
			// lets remove the first byte and retry parsing
			// System.err.println("skipping invalid byte: " + buffer.charAt(0));
			buffer = buffer.substring(1);
		}
	}

	/**
	 * check if beginning of buffer looks like valid data
	 */
	private boolean bufferProbablyBeginsWithValidData() {
		if (buffer.isEmpty()) {
			return true;
		}

		if (buffer.startsWith("I")){
			
			return true;
		}
		
		if (buffer.startsWith("C") || buffer.startsWith("V")
				|| buffer.startsWith("P")) {
			return true;
		}

		return false;
	}

	private String popMessageFromBuffer() {
		
		int idx = buffer.indexOf("OK");
		if (idx > 0) {
			return popStringFromBuffer(idx+2);
		}

		return null;
	}

	private String popStringFromBuffer(int len) {
		String message = buffer.substring(0, len);
		buffer = buffer.substring(len);
		return message.replaceAll("OK", "");
	}

	public static void runTests() {

	}

//	private static void assertParsedMessages(EndpointUbw32Parser parser,
//			String[] expectedMessages) {
//		int i = 0;
//		String message;
//		while ((message = parser.pop()) != null) {
//			if (i >= expectedMessages.length
//					|| !message.equals(expectedMessages[i])) {
//				throw new AssertionError("invalid message " + message
//						+ ", expected: " + expectedMessages[i]);
//			}
//			i++;
//		}
//		if (i != expectedMessages.length) {
//			throw new AssertionError("invalid message array length " + i);
//		}
//	}

}
